import * as faceapi from "face-api.js";
import { Canvas, Image, ImageData, loadImage } from "canvas";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import jwt from "jsonwebtoken";
import User from '../models/User.js';
import Face from "../models/Face.js";  // ‚úÖ ƒê·∫£m b·∫£o c√≥ d√≤ng n√†y

// C·∫•u h√¨nh Canvas cho Node.js
const __dirname = path.dirname(fileURLToPath(import.meta.url));
faceapi.env.monkeyPatch({ Canvas, Image, ImageData });

// Load model
const loadModels = async () => {
  const modelPath = path.join(__dirname, "../models");
  await faceapi.nets.ssdMobilenetv1.loadFromDisk(modelPath);
  await faceapi.nets.faceLandmark68Net.loadFromDisk(modelPath);
  await faceapi.nets.faceRecognitionNet.loadFromDisk(modelPath);
};

await loadModels();

const trainedDataPath = path.join(__dirname, "../trainedData.json");
const THRESHOLD = 0.6; // üî• Ng∆∞·ª°ng ch·∫•p nh·∫≠n (d∆∞·ªõi 0.6 m·ªõi t√≠nh l√† c√πng m·ªôt ng∆∞·ªùi)

export const trainFaces = async (req, res) => {
  try {
    const user_id = req.user.id;
    if (!user_id) {
      return res.status(401).json({status:401, message: "‚ùå Kh√¥ng t√¨m th·∫•y ID ng∆∞·ªùi d√πng!" });
    }

    const user = await User.findById(user_id);
    if (!user) {
      return res.status(404).json({status:404, message: "‚ùå Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i!" });
    }

    if (!req.files || req.files.length === 0) {
      return res.status(400).json({ status:400,message: "‚ùå C·∫ßn c√≥ ·∫£nh ƒë·ªÉ train!" });
    }

    let trainedFaces = [];
    try {
      trainedFaces = JSON.parse(fs.readFileSync(trainedDataPath));
    } catch (error) {
      console.log("‚ö†Ô∏è Ch∆∞a c√≥ d·ªØ li·ªáu train, t·∫°o m·ªõi...");
    }

    let existingUser = trainedFaces.find((person) => person.user_id === user_id);
    if (!existingUser) {
      existingUser = { user_id, name: user.name, descriptors: [] };
      trainedFaces.push(existingUser);
    }

    let addedCount = 0; // S·ªë ·∫£nh h·ª£p l·ªá ƒë∆∞·ª£c th√™m v√†o
    let tempDescriptors = []; // L∆∞u t·∫°m descriptors ƒë·ªÉ ki·ªÉm tra s·ªë l∆∞·ª£ng

    await Promise.all(
      req.files.map(async (file) => {
        console.log(`üñºÔ∏è ƒêang x·ª≠ l√Ω ·∫£nh: ${file.originalname}`);

        const img = await loadImage(file.path);
        const detection = await faceapi
          .detectSingleFace(img)
          .withFaceLandmarks()
          .withFaceDescriptor();

        fs.unlinkSync(file.path); // üóëÔ∏è X√≥a ·∫£nh sau khi train

        if (!detection) {
          console.log("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y khu√¥n m·∫∑t trong ·∫£nh!");
          return;
        }

        const newDescriptor = Array.from(detection.descriptor);

        // üìå So s√°nh v·ªõi c√°c khu√¥n m·∫∑t ƒë√£ c√≥ c·ªßa user
        if (existingUser.descriptors.length > 0) {
          const distances = existingUser.descriptors.map((desc) =>
            faceapi.euclideanDistance(newDescriptor, desc)
          );

          const minDistance = Math.min(...distances);

          console.log(`üîé Kho·∫£ng c√°ch nh·ªè nh·∫•t: ${minDistance}`);
          if (minDistance > THRESHOLD) {
            console.log("‚ùå ·∫¢nh n√†y c√≥ khu√¥n m·∫∑t kh√°c bi·ªát qu√° nhi·ªÅu, b·ªè qua.");
            return;
          }
        }

        // ‚úÖ N·∫øu khu√¥n m·∫∑t kh·ªõp, th√™m v√†o danh s√°ch t·∫°m
        tempDescriptors.push(newDescriptor);
        addedCount++;
      })
    );

    // ‚ùå N·∫øu s·ªë ·∫£nh h·ª£p l·ªá < 10, h·ªßy training
    if (addedCount < 10) {
      return res.status(400).json({status:400,
        message: `‚ùå Training th·∫•t b·∫°i! C·∫ßn √≠t nh·∫•t 10 ·∫£nh h·ª£p l·ªá, nh∆∞ng ch·ªâ c√≥ ${addedCount}.`,
      });
    }

    // üíæ L∆∞u d·ªØ li·ªáu n·∫øu ƒë·ªß 10 ·∫£nh
    existingUser.descriptors.push(...tempDescriptors);
    fs.writeFileSync(trainedDataPath, JSON.stringify(trainedFaces, null, 2));

    res.json({status:200,
      message: `‚úÖ Training ho√†n t·∫•t! ƒê√£ th√™m ${addedCount} ·∫£nh h·ª£p l·ªá.`,
      user_id,
      name: user.name,
    });

  } catch (error) {
    console.error("‚ùå L·ªói training:", error);
    res.status(500).json({status:500, message: "‚ùå L·ªói server", error: error.message });
  }
};


// export const trainFaces = async (req, res) => {
//   try {
//     // üîí L·∫•y ID user t·ª´ token
//     const user_id = req.user.id;
//     if (!user_id) {
//       return res.status(401).json({ message: "‚ùå Kh√¥ng t√¨m th·∫•y ID ng∆∞·ªùi d√πng!" });
//     }

//     // üîç Ki·ªÉm tra user c√≥ t·ªìn t·∫°i kh√¥ng
//     const user = await User.findById(user_id);
//     if (!user) {
//       return res.status(404).json({ message: "‚ùå Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i!" });
//     }

//     if (!req.files || req.files.length === 0) {
//       return res.status(400).json({ message: "‚ùå C·∫ßn c√≥ ·∫£nh ƒë·ªÉ train!" });
//     }

//     let trainedFaces = [];

//     // üìÇ **ƒê·ªçc d·ªØ li·ªáu ƒë√£ train tr∆∞·ªõc ƒë√≥**
//     if (fs.existsSync(trainedDataPath)) {
//       trainedFaces = JSON.parse(fs.readFileSync(trainedDataPath));
//     }

//     // üîç **T√¨m user ƒë√£ c√≥ d·ªØ li·ªáu train ch∆∞a**
//     let existingUser = trainedFaces.find((person) => person.user_id === user_id);

//     if (!existingUser) {
//       existingUser = { user_id, name: user.name, descriptors: [] };
//       trainedFaces.push(existingUser);
//     }

//     // üì∏ **Duy·ªát qua t·ª´ng ·∫£nh v√† tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng**
//     for (const file of req.files) {
//       console.log(`üñºÔ∏è ƒêang x·ª≠ l√Ω ·∫£nh: ${file.originalname}`);

//       const img = await loadImage(file.path);
//       const detection = await faceapi
//         .detectSingleFace(img)
//         .withFaceLandmarks()
//         .withFaceDescriptor();

//       if (detection) {
//         const descriptor = Array.from(detection.descriptor);
//         existingUser.descriptors.push(descriptor); // üîÑ Th√™m descriptor v√†o danh s√°ch
//       }

//       fs.unlinkSync(file.path); // üóëÔ∏è X√≥a ·∫£nh sau khi train
//     }

//     // üíæ **L∆∞u d·ªØ li·ªáu ƒë√£ train**
//     fs.writeFileSync(trainedDataPath, JSON.stringify(trainedFaces, null, 2));

//     res.json({ message: "‚úÖ Training ho√†n t·∫•t!", user_id, name: user.name });

//   } catch (error) {
//     console.error("‚ùå L·ªói training:", error);
//     res.status(500).json({ message: "‚ùå L·ªói server", error });
//   }
// };

// üü¢ **H√†m nh·∫≠n di·ªán khu√¥n m·∫∑t**
// export const verifyFace = async (req, res) => {
//   try {
//     if (!req.file) return res.status(400).json({ message: "‚ùå Kh√¥ng c√≥ ·∫£nh t·∫£i l√™n!" });

//     console.log(`üì∏ ·∫¢nh t·∫£i l√™n: ${req.file.path}`);
//     const imgPath = path.join(__dirname, "../", req.file.path);
//     const img = await loadImage(imgPath);

//     const detection = await faceapi
//       .detectSingleFace(img)
//       .withFaceLandmarks()
//       .withFaceDescriptor();

//     if (!detection) return res.status(400).json({ message: "‚ùå Kh√¥ng t√¨m th·∫•y khu√¥n m·∫∑t n√†o!" });

//     const uploadedDescriptor = Array.from(detection.descriptor); // üü¢ Chuy·ªÉn th√†nh m·∫£ng s·ªë

//     // üü¢ **ƒê·ªçc & chu·∫©n h√≥a d·ªØ li·ªáu ƒë√£ train**
//     if (!fs.existsSync(trainedDataPath)) {
//       return res.status(500).json({ message: "‚ùå Ch∆∞a c√≥ d·ªØ li·ªáu train!" });
//     }

//     let trainedFaces = JSON.parse(fs.readFileSync(trainedDataPath));

//     trainedFaces = trainedFaces.map(person => ({
//       label: person.label,
//       descriptors: person.descriptors.map(desc => Array.isArray(desc) ? desc : Object.values(desc)) // üü¢ Chu·∫©n h√≥a d·ªØ li·ªáu c≈©
//     }));

//     let bestMatch = { label: "Kh√¥ng x√°c ƒë·ªãnh", distance: Infinity };

//     trainedFaces.forEach((person) => {
//       if (!person.descriptors || !Array.isArray(person.descriptors) || person.descriptors.length === 0) {
//         console.log(`‚ö†Ô∏è Kh√¥ng c√≥ descriptors cho: ${person.label}`);
//         return;
//       }

//       person.descriptors.forEach((desc) => {
//         const distance = faceapi.euclideanDistance(uploadedDescriptor, desc);
//         if (distance < bestMatch.distance) {
//           bestMatch = { label: person.label, distance };
//         }
//       });
//     });

//     // üü¢ **Ng∆∞·ª°ng nh·∫≠n di·ªán**
//     if (bestMatch.distance < 0.5) {
//       res.json({ message: `‚úÖ Nh·∫≠n di·ªán th√†nh c√¥ng!`, name: bestMatch.label, distance: bestMatch.distance });
//     } else {
//       res.json({ message: "‚ùå Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c khu√¥n m·∫∑t!", name: "Kh√¥ng x√°c ƒë·ªãnh", distance: bestMatch.distance });
//     }

//     fs.unlinkSync(imgPath); // üü¢ X√≥a ·∫£nh sau khi x·ª≠ l√Ω

//   } catch (error) {
//     console.error("‚ùå L·ªói server:", error);
//     res.status(500).json({ message: "‚ùå L·ªói server", error });
//   }
// };

// export const verifyFace = async (req, res) => {
//   try {
//     if (!req.file) return res.status(400).json({ message: "‚ùå Kh√¥ng c√≥ ·∫£nh t·∫£i l√™n!" });

//     console.log(`üì∏ ·∫¢nh t·∫£i l√™n: ${req.file.path}`);
//     const imgPath = path.join(__dirname, "../", req.file.path);
//     const img = await loadImage(imgPath);

//     const detection = await faceapi
//       .detectSingleFace(img)
//       .withFaceLandmarks()
//       .withFaceDescriptor();

//     if (!detection) return res.status(400).json({ message: "‚ùå Kh√¥ng t√¨m th·∫•y khu√¥n m·∫∑t n√†o!" });

//     const uploadedDescriptor = Array.from(detection.descriptor);

//     if (!fs.existsSync(trainedDataPath)) {
//       return res.status(500).json({ message: "‚ùå Ch∆∞a c√≥ d·ªØ li·ªáu train!" });
//     }

//     let trainedFaces = JSON.parse(fs.readFileSync(trainedDataPath));

//     trainedFaces = trainedFaces.map(person => ({
//       label: person.label,
//       descriptors: person.descriptors.map(desc => Array.isArray(desc) ? desc : Object.values(desc))
//     }));

//     let bestMatch = { label: "Kh√¥ng x√°c ƒë·ªãnh", distance: Infinity };

//     trainedFaces.forEach((person) => {
//       if (!person.descriptors || !Array.isArray(person.descriptors) || person.descriptors.length === 0) {
//         console.log(`‚ö†Ô∏è Kh√¥ng c√≥ descriptors cho: ${person.label}`);
//         return;
//       }

//       person.descriptors.forEach((desc) => {
//         const distance = faceapi.euclideanDistance(uploadedDescriptor, desc);
//         if (distance < bestMatch.distance) {
//           bestMatch = { label: person.label, distance };
//         }
//       });
//     });

//     fs.unlinkSync(imgPath); // X√≥a ·∫£nh sau khi x·ª≠ l√Ω

//     if (bestMatch.distance < 0.5) {
//       // ‚úÖ N·∫øu nh·∫≠n di·ªán th√†nh c√¥ng, t·∫°o token t·∫°m th·ªùi
//       const authToken = jwt.sign({ name: bestMatch.label }, process.env.JWT_SECRET, { expiresIn: "2m" });

//       return res.json({
//         message: `‚úÖ Nh·∫≠n di·ªán th√†nh c√¥ng!`,
//         name: bestMatch.label,
//         distance: bestMatch.distance,
//         token: authToken, // üî• G·ª≠i token v·ªÅ frontend
//       });
//     } else {
//       return res.json({ message: "‚ùå Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c khu√¥n m·∫∑t!", name: "Kh√¥ng x√°c ƒë·ªãnh", distance: bestMatch.distance });
//     }

//   } catch (error) {
//     console.error("‚ùå L·ªói server:", error);
//     res.status(500).json({ message: "‚ùå L·ªói server", error });
//   }
// };

// export const verifyFace = async (req, res) => {
//   try {
//       if (!req.file) return res.status(400).json({ message: "‚ùå Kh√¥ng c√≥ ·∫£nh t·∫£i l√™n!" });

//       console.log(`üì∏ ·∫¢nh t·∫£i l√™n: ${req.file.path}`);
//       const imgPath = path.join(__dirname, "../", req.file.path);
//       const img = await loadImage(imgPath);

//       const detection = await faceapi
//           .detectSingleFace(img)
//           .withFaceLandmarks()
//           .withFaceDescriptor();

//       if (!detection) return res.status(400).json({ message: "‚ùå Kh√¥ng t√¨m th·∫•y khu√¥n m·∫∑t n√†o!" });

//       const uploadedDescriptor = Array.from(detection.descriptor);

//       if (!fs.existsSync(trainedDataPath)) {
//           return res.status(500).json({ message: "‚ùå Ch∆∞a c√≥ d·ªØ li·ªáu train!" });
//       }

//       let trainedFaces = JSON.parse(fs.readFileSync(trainedDataPath));

//       let bestMatch = { label: "Kh√¥ng x√°c ƒë·ªãnh", distance: Infinity };

//       trainedFaces.forEach((person) => {
//           person.descriptors.forEach((desc) => {
//               const distance = faceapi.euclideanDistance(uploadedDescriptor, desc);
//               if (distance < bestMatch.distance) {
//                   bestMatch = { label: person.label, distance };
//               }
//           });
//       });

//       fs.unlinkSync(imgPath);

//       if (bestMatch.distance < 0.5) {
//           const oldToken = req.headers.authorization?.split(" ")[1];
//           if (!oldToken) return res.status(401).json({ message: "Thi·∫øu token ƒëƒÉng nh·∫≠p!" });

//           const decoded = jwt.verify(oldToken, process.env.JWT_SECRET);

//           // üî• Chuy·ªÉn `name` th√†nh `id`
//           const student = await User.findOne({ name: bestMatch.label });
//           if (!student) return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y sinh vi√™n!" });

//           const newToken = jwt.sign(
//               { id: student._id, is_face_verified: true },
//               process.env.JWT_SECRET,
//               { expiresIn: "1h" }
//           );

//           return res.json({ message: `‚úÖ Nh·∫≠n di·ªán th√†nh c√¥ng!`, token: newToken });
//       } else {
//           return res.status(400).json({ message: "‚ùå Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c khu√¥n m·∫∑t!" });
//       }
//   } catch (error) {
//       console.error("‚ùå L·ªói server:", error);
//       res.status(500).json({ message: "‚ùå L·ªói server", error });
//   }
// };

export const verifyFace = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({status:400, message: "‚ùå C·∫ßn t·∫£i l√™n ·∫£nh!" });
    }

    console.log(`üì∏ ·∫¢nh t·∫£i l√™n: ${req.file.path}`);

    // üìå **L·∫•y token t·ª´ request header**
    const token = req.headers.authorization?.split(" ")[1]; // "Bearer <token>"
    if (!token) {
      return res.status(401).json({status:401, message: "‚ùå Ch∆∞a ƒëƒÉng nh·∫≠p!" });
    }

    // ‚úÖ **Gi·∫£i m√£ token**
    let decoded;
    try {
      decoded = jwt.verify(token, process.env.JWT_SECRET);
    } catch (error) {
      return res.status(401).json({status:401, message: "‚ùå Token kh√¥ng h·ª£p l·ªá!" });
    }

    console.log(`üîë Token gi·∫£i m√£:`, decoded);

    const { activity_id } = req.body;
    if (!activity_id) {
      return res.status(400).json({status:400, message: "‚ùå Thi·∫øu activity_id!" });
    }

    // üîç **ƒê·ªçc d·ªØ li·ªáu khu√¥n m·∫∑t ƒë√£ train**
    if (!fs.existsSync(trainedDataPath)) {
      return res.status(400).json({ status:400,message: "‚ùå Ch∆∞a c√≥ d·ªØ li·ªáu khu√¥n m·∫∑t ƒë√£ train!" });
    }
    const trainedFaces = JSON.parse(fs.readFileSync(trainedDataPath, "utf8"));

    // üì∑ **Tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng khu√¥n m·∫∑t t·ª´ ·∫£nh t·∫£i l√™n**
    const img = await loadImage(req.file.path);
    const detection = await faceapi
      .detectSingleFace(img)
      .withFaceLandmarks()
      .withFaceDescriptor();

    if (!detection) {
      return res.status(400).json({ status:400,message: "‚ùå Kh√¥ng t√¨m th·∫•y khu√¥n m·∫∑t trong ·∫£nh!" });
    }

    const uploadedDescriptor = detection.descriptor;
    let bestMatch = null;
    let minDistance = Infinity;

    // üîç **So s√°nh v·ªõi d·ªØ li·ªáu ƒë√£ train**
    for (const person of trainedFaces) {
      for (const descriptor of person.descriptors) {
        const distance = faceapi.euclideanDistance(uploadedDescriptor, descriptor);
        if (distance < minDistance) {
          minDistance = distance;
          bestMatch = person;
        }
      }
    }

    console.log(`üéØ K·∫øt qu·∫£ nh·∫≠n di·ªán: ${bestMatch?.user_id || "Kh√¥ng t√¨m th·∫•y"}`);
    console.log(`üìè Kho·∫£ng c√°ch: ${minDistance}`);

    const THRESHOLD = 0.5; // Ng∆∞·ª°ng x√°c th·ª±c khu√¥n m·∫∑t

    if (bestMatch && minDistance < THRESHOLD) {
      const recognizedUserId = bestMatch.user_id;

      // üîÑ **So s√°nh v·ªõi `user_id` t·ª´ token**
      if (recognizedUserId === decoded.id) {
        // üîë **T·∫°o token m·ªõi c√≥ th√™m `activity_id`**
        const newToken = jwt.sign(
          { id: decoded.id, email: decoded.email, role: decoded.role, activity_id },
          process.env.JWT_SECRET,
          { expiresIn: "30m" }
        );

        return res.json({status:200,
          message: "‚úÖ X√°c th·ª±c khu√¥n m·∫∑t th√†nh c√¥ng!",
          user_id: recognizedUserId,
          distance: minDistance,
          token: newToken,
        });
      } else {
        return res.status(403).json({status:403, message: "‚ùå User kh√¥ng kh·ªõp v·ªõi token ƒëƒÉng nh·∫≠p!" });
      }
    } else {
      return res.status(400).json({status:400, message: "‚ùå Kh√¥ng t√¨m th·∫•y khu√¥n m·∫∑t kh·ªõp!" });
    }
  } catch (error) {
    console.error("‚ùå L·ªói nh·∫≠n di·ªán khu√¥n m·∫∑t:", error);
    res.status(500).json({status:500, message: "‚ùå L·ªói server", error: error.message });
  } finally {
    if (req.file) fs.unlinkSync(req.file.path); // üóëÔ∏è X√≥a ·∫£nh sau khi x·ª≠ l√Ω
  }
};
// L∆∞u d·ªØ li·ªáu khu√¥n m·∫∑t
// L∆∞u d·ªØ li·ªáu khu√¥n m·∫∑t theo userId t·ª´ token
export const saveFaceData = async (req, res) => {
  try {
      const userId = req.user.id;
      console.log("Received request:", req.body); // üëâ Debug d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c

      const { faceData } = req.body;

      if (!faceData) {
          return res.status(400).json({ message: "Missing faceData" });
      }

      let face = await Face.findOne({ userId });

      if (face) {
          face.faceData = faceData;
          await face.save();
          return res.status(200).json({ message: "Face data updated successfully!" });
      }

      face = new Face({ userId, faceData });
      await face.save();

      return res.status(201).json({ message: "Face data saved successfully!" });
  } catch (error) {
      return res.status(500).json({ message: "Error saving face data", error: error.message });
  }
};


// L·∫•y d·ªØ li·ªáu khu√¥n m·∫∑t d·ª±a v√†o userId t·ª´ token
export const getFaceData = async (req, res) => {
  try {
      const userId = req.user.id; // L·∫•y userId t·ª´ token
      const face = await Face.findOne({ userId });

      if (!face) {
          return res.status(404).json({ message: "Face data not found" });
      }

      return res.status(200).json(face);
  } catch (error) {
      return res.status(500).json({ message: "Error retrieving face data", error: error.message });
  }
};